// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using OSS.GenerateNotice.Models;
using System.Collections.Immutable;
using System.CommandLine;
using System.Linq;
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text.Json;
using System.Net;
using Polly;
using Polly.Extensions.Http;

namespace OSS.GenerateNotice
{
    public class Program
    {
        private static readonly JsonSerializerOptions SerializerOptions = new()
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
            WriteIndented = true
        };

        public static async Task<int> Main(string[] args)
        {
            const int DefaultBatchSize = 100;
            const int DefaultRetryCount = 3;

            var rootCommand = new RootCommand("Third-party notice generator");

            var assetFilesOption = new Option<List<string>>("--asset-files", "One or more paths to project.assets.json file(s).")
            {
                Arity = ArgumentArity.ZeroOrMore,
                AllowMultipleArgumentsPerToken = true,
                IsRequired = false
            };

            var npmListJsonFilesOption = new Option<List<string>>("--npm-list-json-files", "One or more paths to files generated by the 'npm list -a --json' command.")
            {
                Arity = ArgumentArity.ZeroOrMore,
                AllowMultipleArgumentsPerToken = true,
                IsRequired = false
            };

            var outputOption = new Option<string>("--output-file", "Path where the generated NOTICE file will be saved.")
            {
                IsRequired = true
            };

            var preambleFileOption = new Option<string>("--preamble-file", "Path to a text file whose contents will be included at the top of the generated NOTICE file.")
            {
                IsRequired = false
            };

            var batchSizeOption = new Option<int?>("--batch-size", $"Numbers of libraries to submit on a single API call. Batches will be submitted sequentially. The default is {DefaultBatchSize}.")
            {
                IsRequired = false
            };

            var retryCount = new Option<int?>("--retry-count", $"Number of retries for each API call. The default is {DefaultRetryCount}.");

            rootCommand.AddOption(assetFilesOption);
            rootCommand.AddOption(npmListJsonFilesOption);
            rootCommand.AddOption(outputOption);
            rootCommand.AddOption(preambleFileOption);

            try
            {
                rootCommand.SetHandler(async (assetFiles, npmListJsonFiles, outputFile, preambleFile, batchSize, retryCount) =>
                {
                    var arguments = new ToolArguments
                    (
                        AssetFiles: assetFiles.Select(ResolvePath).ToImmutableArray(),
                        NpmListJsonFiles: npmListJsonFiles.Select(ResolvePath).ToImmutableArray(),
                        OutputFile: ResolvePath(outputFile),
                        PreambleFile: ResolveOptionalPath(preambleFile),
                        BatchSize: batchSize ?? DefaultBatchSize,
                        RetryCount: retryCount ?? DefaultRetryCount
                    );

                    await MainInternal(arguments);
                }, assetFilesOption, npmListJsonFilesOption, outputOption, preambleFileOption, batchSizeOption, retryCount);

                return await rootCommand.InvokeAsync(args);
            }
            catch(ApplicationException exception)
            {
                Console.Error.WriteLine(exception.Message);
                return 1;
            }
        }

        public record ToolArguments(
            ImmutableArray<string> AssetFiles,
            ImmutableArray<string> NpmListJsonFiles,
            string OutputFile,
            string? PreambleFile,
            int BatchSize,
            int RetryCount);

        private static async Task MainInternal(ToolArguments arguments)
        {
            var nugetDependencies = arguments.AssetFiles
                .Select(assetFilePath => DeserializeFile<ProjectAssetsFile>(assetFilePath))
                .SelectMany(assetFile => assetFile.Libraries.Values)
                .Where(library => string.Equals(library.Type, "package", StringComparison.OrdinalIgnoreCase))
                .Select(library => library.Path)
                .Distinct()
                .ToImmutableArray();

            Console.WriteLine($"NuGet dependency count = {nugetDependencies.Length}");
            
            var npmDependencies = arguments.NpmListJsonFiles
                .Select(npmListJsonFile => DeserializeFile<NpmListJsonFile>(npmListJsonFile))
                .SelectMany(file => SelectAllDependencies(file))
                .Distinct()
                .ToImmutableArray();
            Console.WriteLine($"NPM dependency count = {npmDependencies.Length}");

            var client = new HttpClient();
            client.DefaultRequestHeaders.Accept.Clear();
            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

            var requests = CreateNoticeRequests(nugetDependencies, npmDependencies, arguments.BatchSize);

            // the ClearlyDefined service API has higher chances of failure with larger batch sizes
            // Component Governance uses a batch size of 100
            var processedCoordinates = 0;
            var responses = new List<NoticeResponse<NoticeResponseJsonContent>>();
            for(int i = 0; i < requests.Length; i++)
            {
                var request = requests[i];

                Console.WriteLine($"Starting batch {i} ({processedCoordinates}..{processedCoordinates + request.Coordinates.Length})");

                responses.Add(await InvokeNoticeApi(client, request, arguments.RetryCount));

                Console.WriteLine($"Completed batch {i}");
                processedCoordinates += request.Coordinates.Length;
            }

            // aggregate all the responses together
            var packages = responses
                .SelectMany(response => response.Content.Packages)
                .ToImmutableArray();

            await WriteNoticeFile(packages, arguments.OutputFile, arguments.PreambleFile);
            Console.WriteLine($"NOTICE file saved to '{arguments.OutputFile}'.");
        }

        private static string? ResolveOptionalPath(string? path) => path is null ? null : ResolvePath(path);

        private static string ResolvePath(string path)
        {
            if (Path.IsPathFullyQualified(path))
            {
                return path;
            }

            return Path.Combine(Environment.CurrentDirectory, path);
        }

        private static T DeserializeFile<T>(string assetFile)
        {
            using var stream = File.OpenRead(assetFile);
            return JsonSerializer.Deserialize<T>(stream, SerializerOptions) ?? throw new Exception($"Unable to deserialize file '{assetFile}'.");
        }

        private static IEnumerable<string> SelectAllDependencies(NpmListJsonFile file)
        {
            static string FormatPath(string name, string version) => $"{name}/{version}";

            static IEnumerable<string> SelectAllDependencyPaths(ImmutableDictionary<string, NpmListJsonFileDependency>? dependencies)
            {
                foreach (var kvp in dependencies ?? ImmutableDictionary<string, NpmListJsonFileDependency>.Empty)
                {
                    yield return FormatPath(kvp.Key, kvp.Value.Version);

                    foreach (var subDependencyPath in SelectAllDependencyPaths(kvp.Value.Dependencies))
                    {
                        yield return subDependencyPath;
                    }
                }
            }

            yield return FormatPath(file.Name, file.Version);
            foreach (var path in SelectAllDependencyPaths(file.Dependencies))
            {
                yield return path;
            }
        }

        private static ImmutableArray<NoticeRequest> CreateNoticeRequests(IEnumerable<string> nugetDependencies, IEnumerable<string> npmDependencies, int batchSize) =>
            nugetDependencies
                .Select(nugetDependency => $"nuget/nuget/-/{nugetDependency}")
                .Concat(npmDependencies.Select(npmDependency => $"npm/npmjs/-/{npmDependency}"))
                .OrderBy(s => s)
                .Chunk(batchSize)
                .Select(batch => new NoticeRequest(batch.ToImmutableArray(), new NoticeRequestOptions(), "json"))
                .ToImmutableArray();

        private static async Task<NoticeResponse<NoticeResponseJsonContent>> InvokeNoticeApi(HttpClient client, NoticeRequest requestBody, int retryCount)
        {
            var response = await HttpPolicyExtensions
                .HandleTransientHttpError()
                .OrResult(response => response.StatusCode == HttpStatusCode.TooManyRequests)
                .WaitAndRetryAsync(retryCount, retryAttempt => TimeSpan.FromSeconds(retryAttempt * 10), (result, delay) => Console.WriteLine($"Retrying after {delay}..."))
                .ExecuteAsync(() => InvokeNoticeApi(client, requestBody));

            if (response.StatusCode != HttpStatusCode.OK)
            {
                var error = await response.Content.ReadAsStringAsync();
                throw new ApplicationException(error);
            }

            var responseBody = await response.Content.ReadFromJsonAsync<NoticeResponse<NoticeResponseJsonContent>>(SerializerOptions) ?? throw new Exception("Unable to deserialize response.");

            // log just the summary
            var summaryForLogging = JsonSerializer.Serialize(responseBody.Summary, SerializerOptions);
            Console.WriteLine(summaryForLogging);

            return responseBody;
        }

        private static async Task<HttpResponseMessage> InvokeNoticeApi(HttpClient client, NoticeRequest requestBody)
        {
            // request messages cannot be reused during retries
            var request = new HttpRequestMessage(HttpMethod.Post, "https://api.clearlydefined.io/notices")
            {
                Content = JsonContent.Create(requestBody)
            };
            Console.WriteLine($"{request.Method.ToString().ToUpperInvariant()} {request.RequestUri}");
            
            var response = await client.SendAsync(request) ?? throw new ApplicationException("Null response was received.");
            Console.WriteLine($"  {response.StatusCode}");
            foreach (var header in response.Headers)
            {
                Console.WriteLine($"  {header.Key}: {string.Join("; ", header.Value)}");
            }

            return response;
        }

        private static async Task WriteNoticeFile(ImmutableArray<NoticeResponseJsonPackage> packages, string outputFilePath, string? preambleFilePath)
        {
            var outputFileDirectory = Path.GetDirectoryName(outputFilePath) ?? throw new ApplicationException($"Unable to obtain directory path for file '{outputFilePath}'.");
            Directory.CreateDirectory(outputFileDirectory);

            using var stream = File.OpenWrite(outputFilePath);
            using var writer = new StreamWriter(stream);

            const string Separator = $"---------------------------------------------------------";

            if (preambleFilePath is not null)
            {
                var preambleContents = await File.ReadAllTextAsync(preambleFilePath);
                await writer.WriteLineAsync(preambleContents);
            }

            foreach (var package in packages)
            {
                await writer.WriteLineAsync(Separator);
                await writer.WriteLineAsync();

                await writer.WriteLineAsync($"{package.Name} {package.Version} - {package.License}");
                await writer.WriteLineAsync(package.Website);

                await writer.WriteLineAsync();

                // the ClearlyDefined notice API has a bug where it attributes the copyright of the NuGet signing tool to every package
                // as per instructions from CELA, we are stripping it out until the bug is fixed
                var copyrights = package.Copyrights?.Where(copyright => !string.Equals(copyright, "(c) 2008 VeriSign, Inc.", StringComparison.OrdinalIgnoreCase));
                foreach (var copyright in copyrights ?? ImmutableArray<string>.Empty)
                {
                    await writer.WriteLineAsync(copyright);
                }

                await writer.WriteLineAsync();

                await writer.WriteLineAsync(package.Text);

                await writer.WriteLineAsync();

                await writer.WriteLineAsync(Separator);
                await writer.WriteLineAsync();
            }

            await writer.FlushAsync();
        }
    }
}
